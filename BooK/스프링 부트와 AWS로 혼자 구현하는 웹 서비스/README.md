> 책을 읽어가며 필요한 부분들, 기억해야 할 부분들에 대한 기록.  
> 잘못 알고있던, 혹은 혼동되서 알고있던 기록들도 전부 기록.

<br>

## **Chap.02 : 스프링 부트에서 테스트 코드를 작성하자**

### **P.52**

**태스트 코드에 대한 소개**

> 1. TDD와 단위 테스트(Unit Test)는 다르다.
> 2. TDD는 테스트가 주도하는 개발로 `테스트 코드를 먼저 작성`하는 것에서부터 시작한다.

---

**TDD의 사이클링 순서**

1. Red - 항상 실패하는 테스트를 먼저 작성
2. Green - 테스트가 통과하는 프로덕션 코드를 작성
3. Refactor - 테스트가 통과하면 프로덕션 코드의 리팩토링

---

**단위 테스트**

1. 기능 단위의 테스트 코드를 작성하는 것
2. TDD와 달리 테스트코드를 먼저 작성하지도 않으며 리팩토링도 포함되지 않고 순수히 테스트 코드만 만드는 것을 의미

<br>

### **P.53**

**테스트 코드를 작성하는 이유**

1. 단위 테스트는 개발단계 초기에 문제를 발견하도록 도와준다.
2. 단위테스트는 개발자가 나중에 코드를 리팩토링 하거나 라이브러리에 업그레이드등에서 기존 기능이 올바르게 작동하는지 확인이 가능하다.
3. 기능에 대한 불확실성을 감소시킬 수 있다.
4. 시스템에 대한 실제 문서를 제공한다. 즉 테스트 자체가 문서로 사용이 가능하다.

<br>

### **P.54**

**저자가 느낀 테스트코드의 필요성**

1. 소스코드의 수정이 있는 경우 매번 수정을 할 때마다 사람이 직접 빌드를 하고 검수를 해야한다.
   1. 불필요한 많은 시간이 소요된다.
2. 개발자가 만든 기능을 안전하게 보호한다
   1. 개발자가 기능을 추가하거나 수정하게 될 경우 해당 기능이 아닌 다른 기능에서의 문제도 검증을 해줄 수 있다.
   2. 사람이 직접 수정, 추가점이 발생할 때마다 모든 기능을 테스트 할 수 없기 떄문
      1. 기존 기능이 잘 작동되는것을 보장 하는것

<br>

### **P.55**

**프로젝트 패키지명 구성**

> 도메인 주소가 admin.jojoldu.com이라면 패키지는 역순인 com.jojoldu.admin 으로 구성하면 된다.

<br>

### **P.57**

**@SpringBootApplication Annotation**

> 스프링 부트의 자동 설정, 스프링 Bean 읽기와 생성을 모두 자동으로 설정해준다.  
> 해당 어노테이션이 `존재하는 위치부터 설정을 읽어가기 때문`에 항상 프로젝트 최상단에 존재하여야 한다.

> `Main`의 `SpringApplication.run`메소드로 내장WAS(톰캣)을 실행한다.

<br>

### **P.58**

**왜 SpringBoot에선 내장WAS의 사용을 권장하는지?**

> 언제 어디서나 `같은 환경`에서 `스프링 부트`를 배포 할 수 있기 떄문이다.  
> 외장 WAS를 사용을 해도 되지만, 사용을 하게 되면 WAS의 종류와 버전, `설정을 모두 일치시켜야 하는 추가적인 작업이 필요`하기 때문, 즉 확장이 불편해지기 떄문

> 내장 WAS를 사용 할 경우 성능상 이슈의 경우에는 크게 고려하지 않아도 된다고 함.

<br>

### **P.72**

**`@RequiredArgsConstructor`란?**

1. 해당 어노테이션이 선언된 모든 final필드가 포함된 생성자를 생성한다.
2. final이 없는 필드는 생성자에 포함되지 않는다.

<br>

## **Chap.03 : 스프링부트에서 JPA로 DB를 다뤄보자**

### **P.79**

> SQL Mapper와 ORM은 구분하자...  
> `MyBatis, iBatis`도 ORM중 하나라고 생각했으나 두개는 `SQL Mapper`로 구분된다.

<br>

### **P.82~84**

**JPA의 이점**

1.  객체지향적으로 프로그래밍을 할 수 있도록 함
2.  SQL에 종속적인 개발을 하지 않을 수 있게 된다.

---

**Spring Data JPA**

> `JPA`는 `인터페이스`로 `자바 표준명세서`이다.  
> 인터페이스인 JPA를 사용하기 위해서는 `구현체가 필요`하며, 대표적으로 `Hibernate, Eclipse Link`등이 있다.  
> 하지만 Spring에서는 JPA를 활용시 `위 구현체를 직접 다루진 않고` 구현체들을 좀 더 쉽게 사용하고자 추상화한 `Spring Data JPA를 활용`한다.

> JPA 변천사 : JPA → Hibernate → Spring Data JPA

> `Hibernate`를 사용하는 것과 `Spring Data JPA`를 사용하는 것에는 `큰 차이는 없다`.  
> 그럼에도 Spring Data JPA를 `다시 제작한 이유는 크게 다음 두가지` 떄문
>
> 1. `구현체 교체`의 용이성
> 2. `저장소 교체`의 용이성

<br>

**구현체 교체의 용이성?**

> `Hibernate`가 언젠가 `수명`을 다해서 `새로운 JPA구현체가 대세로 떠오를 때` Spring Data JPA를 사용중이라면 `쉽게 교체가 가능`하며, Spring Data JPA는 내부에서 구현체 매핑을 지원하기 때문에 가능하다

> 이 예제는 최근 `Redis`에서 증명이 되는데 `Redis클라이언트의 대세`가 `Jedis`에서 `Lettuce`로 넘어 갈 때 `Spring Data Redis`를 사용하는 경우 `쉽게 교체`를 하였음.

<br>

**저장소 교체의 용이성?**

> `관계형 DB`외에 `다른 저장소로 쉽게 교체`하기 위함

> 초창기 서비스시 `관계형 DB`로 `모든 기능을 처리`했지만 트래픽이 많아지면서 관계DB로 유지가 불가능 해 `MongoDB 등등으로 저장소의 변경이 필요한 경우`에 `Spring Data JPA`에서 `Spring Data MongoDB`로 `의존성만 교체`하면 된다.

> `Spring Data`의 `하위 프로젝트들`은 기본적으로 `CRUD인터페이스가 같다`.  
>  그러다보니 `기본적인 기능`의 `변경`이 없어 `Hibernate를 직접 사용하는 것`보다는 `Spring Data프로젝트의 사용을 권장`한다.  
> Ex) Spring Data JPA, Spring Data Redis, Spring Data MongoDB등등

<br>

**실무에서의 JPA**  
적용을 못하는 이유

1. 높은 러닝 커브
2. 객체지향 프로그래밍과 데이터베이스 둘다 이해를 해야함.

적응을 함으로써 이점

1. CRUD쿼리를 직접 작성할 피료가 사라짐.
2. 객체 지향 프로그래밍을 쉽게 할 수 있슴.
   1. 부모-자식 관계 표현
   2. 1:N 관계 표현
   3. 상태와 행위를 한 곳 에서 관리

> 속도와 관련한 이슈는 있다. 하지만 많은 이슈 해결책들이 공유가 되고있는 상태이기 때문에 잘 활용하면 문제가 없다.

<br>

### **P.87**

**라이브러리**

1. `spring-boot-starter-data-jpa`
   1. Spring Boot용 Spring Data Jpa 추상화 Library
   2. Spring Boot의 버전에 맞춰 자동으로 JPA 관련 라이브러리 버전을 관리한다.
2. `h2`
   1. InMemory형 RDBMS
   2. 별도의 설치가 필요 없이 프로젝트 의존성만으로 관리 할 수 있다.
   3. 메모리에서 실행되기 때문에 어플리케이션을 재시작 할 때마다 초기화 되는 점을 활용 해서 테스트 용으로 자주 사용이 된다.

---

**domain 패키지**

> MyBatis나 iBatis같은 SQL Mapper에서 사용하던 dao 패키지 같이 쿼리의 결과등을 담던 일들이 모두 도메인에서 이루어 진다.

> 저자의 경우 `도메인에 대한 세부적인 공부를 더 희망`하는 경우 `최범균(저)-DDD Start`를 추천하였다.

<br>

### **P.91**

**자주 사용 되는 Entity Annotation**

1.  `@Entity`
    1.  `테이블`과 `링크`될 `클래스`
    2.  `기본값`으로 클래스의 `카멜케이스 이름`을 `언더스코어 네이밍(_)`으로 `테이블 명`을 매칭한다.
        1.  Ex) SalesManager.java → sales_manager table
2.  `@Id`
    1.  해당 테이블의 PK를 의미
3.  `@GeneratedValue`
    1.  PK의 생성 규칙을 의미
    2.  `스프링부트 2.0`에서는 `GenerationType.IDENTITY` 옵션을 `추가`해야만 `Auto Increment`가 되었었다.
4.  `@Column`
    1.  `테이블의 컬럼`을 의미하며 굳이 `선언하지 않더라도 해당 클래스의 필드는 모두 컬럼이 된다`.
    2.  사용하는 이유는 `기본값` 외에 `추가로 변경이 필요한 옵션`이 있으면 사용한다.
    3.  문자열의 경우 `VARCHAR(255)가 기본값`이나, `사이즈 증가`, `VARCHAR타입을 TEXT로 변경`이 필요한 경우 등등에 사용한다.

> Entity의 PK의 경우에는 숫자를 사용하면 Long타입의 Auto_Increment를 추천한다.  
> Long을 활용할 경우 MySQL기준 BIGINT형으로 선언이된다.

<br>

### **P.92**

**Setter에 대한 고찰**

> 자바빈 규약을 생각하면서 `Getter, Setter를 무작정 생성하는 경우`가 있다. 그렇게 제작을 하게 되면 해당 클래스의 `인스턴스 값들이 언제 어디서 변해야 하는지` 코드상으로 명확히 `구분 할 수가 없다.` 그 결과로 차후 기능 변경이 복잡해지는 문제가 발생한다..

> 위의 경우에 따라 `Entity클래스`에서는 `절대 Setter메소드를 생성하지 않는다`. 대신 `필드의 값 변경이 필요`한 경우 명확히 그 `목적과 의도를 나타낼 수 있는 메소드를 추가` 한다.

```
// Example Code
// Wrong → 메소드 명의 사용 의미가 불명
public class Order {
   public void setStatus(boolean status){
      this.status = status
   }
}

// Right → 메소드 명에서 사용처의 명확한 이유 파악이 가능
public class Order {
   public void cancelOrder(boolean status){
      this.status = status
   }
}
```

<br>

### **P.93**

**`Setter`가 없이 `Insert`는 어떻게?**

> `Setter`가 없이 DB에 `Insert`는 `생성자를 통해 최종 값을 채운 이후` DB에 `삽입`한다.  
> 또한 `값의 변경이 필요한 경우`에는 해당 이벤트에 맞는 `public 메소드를 호출하여 변경`하는것을 전제로 한다.

> 생성자를 대신해서 `@Builder` 어노테이션을 통해서의 사용도 가능하다.

<br>

### **P.95**

**Repository**

> `iBatis, MyBatis`같은 SQL Mapper를 사용 할 떄에는 `Dao라는 명칭`으로 불리던 `DB Layer`가 `JPA 에서는 Repository`로 칭하며 `Interface로 생성`한다.

> Interface의 생성 후 `JpaRepository<Entity Class, PK 타입>`으로 상속하면 `기본적인 메소드가 자동으로 생성`되며, `@Repository`를 따로 `선언할 필요가 없다`.
>
> > 주의할 사항으로는 `Entity클래스`와 `Entity Repository`는 `함께 위치`해야 한다.  
> > Entity 클래스는 기본 `Repository`없이는 제대로 `역할을 할 수가 없다`.
> >
> > 추후 프로젝트의 규모가 커져 도메인별로 프로젝트를 분리해야 한다면, Entity클래스와 기본 Repository는 함께 움직여야 하므로 도메인 패키지에서 함께 관리한다.

<br>

### **P.97**

**Junit `@After` Annotation**

- Junit에서 단위테스트가 끝날 때마다 수행되는 메소드
- 보통은 배포 전 전체 테스트를 수행 할 때 테스트 간 데이터 침범을 막기 위해 사용한다.
- 여러 테스트가 동시에 수행되면 테스트용 DB인 H2에 데이터가 그대로 남아 있어 다음 테스트 실행 시 실패 할 수가 있다.
- 반대의 사용으로는 `@Before`가 존재하며 단위테스트가 시작되기 전에 수행이 된다.

**JPA Repository Object Method**

1. `RepositoryObject.save`
   1. 테이블에 `insert` / `update` 쿼리를 실행한다.
   2. id값이 있다면 `update`, 없다면 `insert`쿼리를 실행
2. `RepositoryObject.findAll`
   1. 테이블에 존재하는 모든 데이터를 조회하는 메소드.

<br>

### **P.101 ~ 102**

**Layer의 역활**  
내가 너무 크게 잘못 생각하던 부분으로 `비즈니스 로직`의 `처리`하는 것은 `Service`로 알고 있었으나 `Service`에서는 `트랜잭션`, `도메인 간의 순서 보장`역할만 한다..

> 먼저 각 계층이 해당하는 순서는 아래의 리스트와 같다.
>
> 1. Web Layer
>    > 1. 주로 사용되는 `@Controller`와 `JSP` / `Freemarker` 등의 View 템플릿 영역
>    > 2. 외에도 `@Filter`, `인터셉터`, `@ControllerAdvice`등 외부 요청과 응답에 대한 전반적인 영역을 의미
> 2. Service Layer
>    > 1. `@Service`에 사용되는 영역
>    > 2. 보통 `@Controller`와 `Dao`의 중간역할에 사용된다.
>    > 3. `@Transactional`이 사용되어야 하는 영역이다.
> 3. Repository Layer
>    > 1. Database와 같이 `데이터 저장소에 접근`하는 영역
>    > 2. 기존에 `Dao영역`으로 이해하면 좋을 듯 하다.
> 4. Dtos
>    > 1. `계층 간`의 `데아터 교환`을 위한 `객체`를 이야기하며 Dtos는 이들의 영역을 얘기한다.
>    > 2. Ex로 `Web Layer`에서 사용될 객체나 `Repository Layer`에서 결과로 넘겨준 객체등이 Dtos를 의미
> 5. Domain Model
>    > 1. 도메인이라 불리는 `개발 대상`을 모든 사람이 `동일한 관점`에서 `이해` 할 수 있고 `공유`할 수 있도록 `단순화` 한 것을 도메인 모델이라 칭함.
>    > 2. 택시앱이 예제일 경우 `배차`, `탑승`, `요금` 등이 모두 도메인이 될 수가 있다
>    > 3. `@Entity`가 사용된 영역 역시 `도메인 모델`로 이해하면 좋다.
>    > 4. 무조건 `데이터베이스의 테이블`(@Entity)과 관계가 있어야만 하는 것은 아니다.
>    > 5. `VO`처럼 `값 객체`들도 `도메인 모델` 영역에 해당 한다.
>
> 해당 `Web`, `Service`, `Repository`, `Dto`, `Domain` 5개 Layer에서 `비즈니스 로직을 처리`하는 Layer는 `Domain`이며,  
>  `Service Layer`에서 처리하던 방식을 `트랜잭션 스크립트`라고 한다.

<br>

### **P.106**

**Bean 주입과 관련하여**
Bean주입을 할때 방법은 3개로 `@Autowired`, `Setter`, `생성자` 3개가 있다.  
그 중 권장하는 방법은 `생성자를 통한 주입`이며, `@RequiredArgsConstructor` 어노테이션의 경우에는 `final로 선언된 모든 필드의 인자값`으로 하는 생성자를 롬복이 생성한다.

<br>

### **P.107**

**Entity와 Dto**
작성을 하면서 이해가 되지 않았던 부분이다. Entity와 Dto가 거의 유사한 코드로 진행되었는데 왜? 굳이? Dto로 따로 제작을 하였는지가 의문이었다.

> Entity클래스를 절대로 Request / Response클래스로 사용해서는 안된다.  
> Entity클래스는 Database와 맞닿은 핵심 클래스이다. 따라서 Entity클래스를 기준으로 테이블이 생성되고 스키마가 변경된다.  
> 화면 변경은 아주 사소한 기능 변경인데 이를 위해 테이블과 연결된 Entity클래스를 변경하는 것은 너무 큰 변경이기 떄문에 하면 안된다.

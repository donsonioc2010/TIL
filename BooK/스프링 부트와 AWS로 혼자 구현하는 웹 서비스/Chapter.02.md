# **Chapter.02 스프링 부트에서 테스트 코드를 작성하자**

## Index

- [**Chapter.02 스프링 부트에서 테스트 코드를 작성하자**](#chapter02-스프링-부트에서-테스트-코드를-작성하자)
  - [Index](#index)
  - [테스트 코드에 대한 소개](#테스트-코드에-대한-소개)
    - [TDD에 대해서](#tdd에-대해서)
    - [TDD의 사이클링 순서](#tdd의-사이클링-순서)
    - [단위 테스트](#단위-테스트)
    - [테스트 코드를 작성하는 이유](#테스트-코드를-작성하는-이유)
    - [저자가 느낀 테스트 코드의 필요성](#저자가-느낀-테스트-코드의-필요성)
    - [책을 다읽고 느낀 나의 테스트코드의 필요성](#책을-다읽고-느낀-나의-테스트코드의-필요성)
  - [Hello Controller 테스트 코드 작성하기](#hello-controller-테스트-코드-작성하기)
    - [프로젝트 패키지명 구성(작성) 방식](#프로젝트-패키지명-구성작성-방식)
    - [`@SpringBootApplication` Annotation](#springbootapplication-annotation)
    - [왜 SpringBoot에선 내장WAS의 사용을 하는 이유](#왜-springboot에선-내장was의-사용을-하는-이유)
  - [HelloController 코드를 Lombok으로 전환하기](#hellocontroller-코드를-lombok으로-전환하기)
    - [`@RequiredArgsConstructor`란?](#requiredargsconstructor란)

## 테스트 코드에 대한 소개

### TDD에 대해서

> 1. `TDD`와 `단위 테스트(Unit Test)`는 다르다.
> 2. `TDD`는 **테스트가 주도하는 개발**로 `테스트 코드를 먼저 작성`하는 것에서부터 시작한다.

### TDD의 사이클링 순서

1. `Red` - `항상 실패하는 테스트`를 먼저 작성
2. `Green` - `테스트가 통과하는 프로덕션 코드`를 작성
3. `Refactor` - 테스트가 통과하면 `프로덕션 코드의 리팩토링`

### 단위 테스트

1. `기능 단위의 테스트 코드`를 작성하는 것
2. `TDD`와 다르게 `테스트코드를 먼저 작성하지도 않으며 리팩토링도 포함되지 않고 순수히 테스트 코드만 만드는 것`을 의미한다.

### 테스트 코드를 작성하는 이유

1. `단위 테스트`는 `개발단계 초기에 문제를 발견`하도록 도와준다.
2. `단위테스트`는 개발자가 나중에 `코드를 리팩토링` 하거나 `라이브러리에 업그레이드`등에서 **기존 기능이 올바르게 작동하는지 확인이 가능**하다.
3. `기능에 대한 불확실성`을 **감소**시킬 수 있다.
4. `시스템에 대한 실제 문서를 제공`한다. 즉 **테스트 자체가 문서로 사용**이 가능하다.

### 저자가 느낀 테스트 코드의 필요성

1. `소스코드의 수정`이 있는 경우 `매번 수정을 할 때`마다 `사람이 직접 빌드를 하고 검수`를 해야한다.
   1. `불필요한 많은 시간`이 소요된다.
2. 개발자가 `만든 기능`을 안전하게 `보호`한다
   1. 개발자가 `기능을 추가`하거나 `수정`하게 될 경우 해당 기능이 아닌 **다른 기능에서의 문제도 검증**을 해줄 수 있다.
   2. `사람이 직접 수정, 추가점이 발생할 때`마다 **모든 기능을 테스트 할 수 없기 떄문**
      1. 기존 기능이 잘 작동되는것을 보장 하는것

### 책을 다읽고 느낀 나의 테스트코드의 필요성

1. 소스코드의 비즈니스 로직이 수정이 될 때 타 기능에 까지 영향을 미치는지 즉각적인 확인이 가능하다.
2. 개발자가 만든 기능에 대해서 해당 기능이 확실하게 제 역할을 수행중이라고 할 수 있다.

## Hello Controller 테스트 코드 작성하기

### 프로젝트 패키지명 구성(작성) 방식

> `도메인 주소`가 `admin.jojoldu.com`이라면 패키지는 역순인 `com.jojoldu.admin` 으로 구성하면 된다.

### `@SpringBootApplication` Annotation

> 스프링 부트의 `자동 설정`, 스프링 `Bean 읽기와 생성`을 `모두 자동으로 설정`해준다.  
> 해당 어노테이션이 `존재하는 위치부터 설정을 읽어가기 때문`에 항상 프로젝트 최상단에 존재하여야 한다.

> `Main`의 `SpringApplication.run`메소드로 내장WAS(톰캣)을 실행한다.

### 왜 SpringBoot에선 내장WAS의 사용을 하는 이유

> 언제 어디서나 `같은 환경`에서 `스프링 부트`를 배포 할 수 있기 떄문이다.  
> 외장 WAS를 사용을 해도 되지만, 사용을 하게 되면 WAS의 종류와 버전, `설정을 모두 일치시켜야 하는 추가적인 작업이 필요`하기 때문, 즉 확장이 불편해지기 떄문

> 내장 WAS를 사용 할 경우 성능상 이슈의 경우에는 크게 고려하지 않아도 된다고 함.

<br>

## HelloController 코드를 Lombok으로 전환하기

### `@RequiredArgsConstructor`란?

1. `해당 어노테이션`이 선언된 `모든 final필드`가 `포함된 생성자를 생성`한다.
2. `final이 없는 필드`는 생성자에 `포함되지 않는다`.

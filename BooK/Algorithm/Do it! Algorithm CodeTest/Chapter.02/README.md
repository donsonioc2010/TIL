# **Chapter 02**

## **자료구조**

### **배열과 리스트**

#### **배열**

> 배열은 `메모리의 연속 공간`에 값이 채워진 형태의 자료구조이다.

#### **배열의 특징**

1. `배열의 인덱스`를 통해 값의 참조
2. `배열을 선언했을때의 자료형만` 저장이 가능
3. `한번 선언을 한 경우 크기를 줄이거나 늘릴 수 없다`

#### **리스트**

> 리스트는 `값`과 `포인터`를 묶은 `노드`를 포인터로 연결한 방식의 자료구조이다.

#### **리스트의 특징**

1. `인덱스가 없다.` 따라서 접근을 위해서는 `Head포인터부터 순서대로 접근`해야 하므로 `접근 속도가 느리다.`
2. 포인터로의 연결되어 있으므로 `데이터의 삽입또는 삭제의 연산이 빠르다`
3. 선언을 할 때 `크기의 지정이 필요하지 않다.`
4. `포인터를 저장할 공간`이 필요하여 `배열보다 구조가 복잡하다.`

---

### **구간 합**

> 시간복잡도를 줄이기 위해 사용하는 특수한 목적의 알고리즘이다.

#### **구간합 배열 제작법 및 사용법**

> **제작법**
>
> 1. 배열 선언
> 2. S[i] = A[0]~A[i]까지의 값 합
>    1. S[i] = S[i-1] + A[i]로도 제작이 가능

> **사용법**  
> EX ) A[2]~A[5] 구간합이 필요한 경우  
> S[5] - S[1] == A[2]~A[5]의 합

#### 2차 배열의 구간합 예제

> 모든 데이터를 더한다고 생각을 해야한다..?
> 구간합을 제작하는 경우에는 각각 ((x, y-1) + (x-1, y)) - (x-1, y-1) + Value 공식으로 제작

> (x1, y1)~(x2,y2)합을 구하는 경우 x2,y2에서 x2, y1-1 와 x1-1, y2 의 값 뺀 이후 공통으로 뺀 x1 -1, y1 -1 의 값을 더해야 한다.

EX Data)  
1,2,3,4  
2,3,4,5  
3,4,5,6  
4,5,6,7

↓↓↓↓

1,3,6,10  
3,8,15,24  
6,15,27,42  
10,24,42,64

### **투 포인터**

> 투포인터는 2개의 포인터로 알고리즘의 시간 복잡도를 최적화 한다.

while로 사용하는게 편해보인다...

index 포인트를 2개를 사용해야 함.
같은 Index에서 시작하는 방식, 양끝에서 시작하는 방식인듯?

### **슬라이딩 윈도우**

> 두개의 포인터로 범위를 지정한 다음 범위를 유지한채 이동하는 방식의 문제 해결법  
> 투포인터 알고리즘과 매우 유사하다.  
> 인덱스를 유지하면서 이동하는게 포인트

> 덱 Deque
> 덱은 addFirst, removeFirst, addLast, removeLast를 통해서 양 끝에서 데이터를 삽입, 삭제할 수 있는 자료구조 이다.

### **스택과 큐**

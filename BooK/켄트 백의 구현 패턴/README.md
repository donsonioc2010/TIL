# 켄트 백의 구현 패턴

# 01. 소개

## 책의 목적

```ad-info
해당 도서는 결국 커뮤니케이션을 돕는 프로그래밍 기법에 대한 내용이다.
```

## 코드를 통한 커뮤니케이션 방법의 단계

1. 생각을 하며 프로그래밍 하는것
   - 뇌빼고 코드를 짜고 있다가도 잠깐식 살펴볼 여유를 가져라
2. 타인의 중요성을 인정하는것
3. 타인의 존재가, 나의 존재만큼 중요하다는 생각과 그생각을 실천으로 옮기는것
   - 여기서의 실천이란 **나 자신만을 위한 코드가 아닌 다른사람을 위한 프로그램**을 작성한 것

## 좋은 변수 명이란?

```ad-info
- 변수의 목적, 변수타입, 변수의 사용범위를 우선 담고있어야 한다.
- 읽기 쉽고, 쓰거나 정형화 하기 쉬어야 한다.
```

---

# 02. 패턴

```ad-info
title: 프로그램은 다음과 같은 법칙이 적용된다.
- 프로그램을 새로 작성하는 경우보다는, 기존 프로그램을 읽는 경우가 많다.
- 프로그램에 있어 **완성**은 없다. 최초에 프로그램을 **개발**하는 데 드는 노력보단 이후 **수정**과 **이슈 해결**에 드는 노력이 더 크다.
- 프로그램 구조는 몇가지 **상태**와 **제어 흐름 개념**으로 결정된다.
- 프로그램을 읽는 사람은 개념과 더불어 세부 사항까지도 이해해야 한다.
  세부 사항을 이해해야 전체 개념의 그림을 그릴 수 있고, 그래야 세부적인 내용을 이해할 수  있기 때문이다.
```

---

# 03. 프로그래밍 이론

```ad-info
title: 프로그램을 잘 작성 사람이란?
- 타인과의 커뮤니케이션을 중시한다.
- 코드의 과도한 복잡성은 피한다.
- 유연성 있는 코드
```

## 가치

> **훌륭한 프로그래밍**의 공통적인 가치는 *커뮤니케이션, 단순성, 유연성*인 경우가 많으며, **뛰어난 프로그래머**는 *프로그램의 확장성*을 고려한 프로그램을 작성하면서, *불필요한 요소*의 사용을 하지 않으면서 _읽고 이해가 쉬운_ 프로그램을 작성한다.

### 커뮤니케이션

#### 타인을 고려해서 프로그램을 작성시 이점

- 내 코드는 좀 더 이해하기 쉽워지며, 더 정돈되고 효율적이고 생각이 명확해진다
- 새로운 관점에서 코드를 볼 여유가 생기고, 타인도 볼 수 있는 코드로 된다
- 더 쉬워지는 만큼 기존의 코드를 수정하는 개발비용이 줄어든다.

### 단순성

> 프로그램을 최대한 단순화한다. 의미없는 코드는 모두 제거하며, 설계시에도 과도한 요소는 모두 뺀다.
> 요구사항을 분석해서 꼭 필요한 사항만을 뽑아내서 과도한 복잡도를 제거하면 코드를 새로운 관점에서 볼 수 있다.

### 유연성

- 비효율적인 코딩이나 설계를 정당화 해주는 가치이다.
- 프로그램은 유연해야 하지만, 프로그램이 발전하는 방향으로 유연해야 한다..
  > 추측에 의거해 설계에 유연성을 부여하는 것보다는 단순성을 유연하게 적용한 후 테스트를 철저하게 하는 편이 더 효과적이다.

## 원칙

> 각 패턴은 커뮤니케이션, 단순성, 유연성의 가추중 하나 이상을 내포한다.

> 원칙은 가치에 비해 좀 더 프로그래밍에 특화된 개념이지만, 가치와 마찬가지로 일반적인 생각을 담고있으며, 패턴의 근간을 이룬다.

### 지역적 변화

- 코드를 수정 할 때 함께 바꿔야 하는 부분을 최소하 하라.
- 여러곳의 수정이 필요한 경우 비용이 커진다.
- 지역만 변경할 경우 커뮤니케이션이 쉬워진다.

### 최소 중복

- 지역적 변화를 돕는 다른 원칙은 최소 중복의 원칙이다.
- 같은 코드가 여러 곳에서 반복된다면 그 중 하나를 바꿀 때 다른 중복된 코드도 모드 변경해야 할 지 여부를 결정해야 한다.
- 중복된 코드가 많으면 많을 수록 코드의 수정은 힘들어 진다.

- 프로그램상에 존재하는 중복에는 코드만이 아니라 병렬 클래스계층도(parallel class hierarchy)도 중복의 일종이다.
- 프로그램상의 어떤 개념을 수정했을 때 2개 이상의 클래스 계층을 수정해야 한다면 이것은 지역적 변화의 원칙을 위배하는 것이다.

### 로직과 데이터의 결합

- 지역적 변화의 원칙에 근거한 다른 원칙은 로직과 데이터를 함께 유지하는 것

---

# 04. 동기유발

- 소프트웨어 설계의 언동력은 경제성이다
- 소프트웨어는 전체 비용을 줄이는 방향으로 설계되야 한다.
  - 비용은 최초 개발비용과 유지비용으로 구분이 가능하다
- 소프트웨어의 경우 개발비용보다는 유지비용이 많이 들어간다
  - 유지비용이 거의 들어가지 않는 프로젝트의 경우에는 해당 책의 구편패턴과 다른종류의 패턴들을 사용해야 할 것..
  - 유지비용이 비싼 이유는 기존에 있는 코드를 이해하는 작업이 시간이 많이 걸리고 어려운 일이기 때문
  - 수정이후 테스트를 한 후 배포 작업을 해야하기 때문

> 전체 비용 = 개발 비용 + 유지 비용  
> 유지 비용 = 코드 이해 비용 + 수정 비용 + 테스트 비용 + 설치(배포) 비용

> ## 전체 비용을 줄이는 한가지 전략으로 초기 개발비용을 많이 투자하는 것이라 생각한다. 하지만 전체 비용의 절감은 하지 못한다. 이유는 미래에 코드를 어떻게 수정해야 할 지 알 수 없기 때문이다.

# 05. 클래스

> 해당 챕터에서 다루는 패턴

| 패턴명                                      | 설명                                                                                     |
| :------------------------------------------ | :--------------------------------------------------------------------------------------- |
| 클래스                                      | *이 데이터들은 함께 사용되며, 관련된 로직이 이것이다*라는 것을 전달하고 싶을때 사용한다. |
| 단순한 상위 클래스 이름                     | 클래스 계층의 최상위에 위치하는 클래스 이름은 단순하게 짓는다                            |
| 한정적 하위클래스 이름                      | 상위 클래스와의 유사점과 차이점을 분명히 드러내는 명칭을 사용한다.                       |
| 추상 인터페이스                             | 인터페이스와 구현을 분리한다                                                             |
| 인터페이스                                  | 상위 클래스와의 유사점과 차이점을 분명히 드러내는 명칭을 사용한다.                       |
| 버전 인터페이스                             | 하위 인터페이스를 사용해 기존 인터페이스를 안전하게 확장한다                             |
| 추상 클래스                                 | 자주 바뀔 것 같은 추상 인터페이스에는 추상 클래스를 사용한다.                            |
| 값 객체                                     | 산술 값 처럼 동작하는 객체를 사용한다.                                                   |
| 특화                                        | 관련된 연산 사이의 유사점 및 차이점을 분명하게 나타낸다                                  |
| 하위 클래스                                 | 1차원 적 변화는 하위클래스를 사용해서 표현한다.                                          |
| 구현자 (implementor)                        | 연산 내용이 바뀌었다면 기존 메소드를 오버라이드 해서 사용한다                            |
| 내부 클래스                                 | 클래스 내부에서 유용하게 사용할 수 있는 코드를 모아 전용 클래스로 사용한다.              |
| 인스턴스별 행동(instance-specific behavior) | 인스턴스에 따라 로직에 변화를준다                                                        |
| 조건문                                      | 명시적 조건에 따라 로직에 변화를 준다                                                    |
| 위임(delgation)                             | 여러 종류의 객체중 하나에 위임해서 로직에 변화를 준다                                    |
| 플로그인 선택자(pluggable selector)         | 리플렉션을 이용한 메소드 호출로 로직에 변화를 준다.                                      |
| 익명 내부 클래스                            | 필요한 메소드에서 한 두개의 메소드만 오버라이드 하는 객체를 만들어서 사용한다.           |
| 라이브러리 클래스                           | 마땅이 들어갈 곳이 없는 기능들을 묶어서 정적 메소드로 표현한다.                          |

## 클래스

- 클래스를 사용하는 기본 이유는 **데이터가 로직에 비해 빈번하게 변화**하기 때문

- 클래스 계층을 구성하는 것은 일종의 압축 기법을 사용하는 것

  - 해당 기법의 사용은 상위 클래스의 코드를 모두 하위클래스에 붙여넣는 것과 같은 효과를 가져온다.
  - **단점**은 하위 클래스를 이해하기 위해서는 상위 클래스도 이해해야 한다. 즉 복잡도가 높아진다.

- 효과적인 객체 지향프로그래밍을 하는 다른 요건은 선별적으로 상속을 사용하는 것이다

  - 하위클래스를 생성하는 것은 **이 클래스는 상위 클래스와 비슷하지만 약간 다르다**를 의미한다.

- 클래스는 객체 지향 프로그램 설계 요소중 값이 비싼편이다
  - 의미있는 작업에만 클래스를 사용하자
  - 다른 클래스의 크기를 너무 비대하게 하지 않으면서 클래스의 수를 줄인 것은 프로그램을 개선한게 맞다.

## 단순한 상위클래스 이름

> 상위 클래스는 명칭을 단순하게 하면서 핵심을 잘 짚어야 한다.  
> 가급적 간결성을 택하는게 좋다.

- 중요한 클래스는 한단어로 된 이름을 사용하자
  - Ex: Scheduler등
- 정확한 의미의 전달을 위해 길게 지어야 하는 경우 메타포(metaphor, 은유)를 사용하자.

## 한정적 하위 클래스 이름

> 하위 클래스 명은 **상위 클래스와의 유사점과 차이점**을 나타내야 한다
> 상위 클래스에서 처럼 간결성과 표현성에서의 고민이라면 **표현성을 택하는게 낫다.**

- 클래스의 명칭을 상위 클래스의 명칭과 함께 수식어를 붙여 확실한 표현성을 갖자.
- 다른 방법은 다단계 클래스 계층이 있다(multi-level hierarchy)

## 추상 인터페이스

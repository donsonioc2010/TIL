# Interface

## Interface에서 선언이 가능한 메소드 종류

## Java8 이후 변동사항

> 기존 Java7 이전의 Interface에서는 abstract클래스밖에 생성이 불가능했다. 그러다보니 구현을 하고싶지 않은 경우 abstract class를 생성해서 interface를 상속받아
> 먼저 구현을 하고 override를 해야했으나 8이 오면서 작업이 불필요해졌었다. 그이유는 다음 두가지의 변경사항떄문이다.

- Default Method의 추가
- Static Method의 추가

### 추상(abstract) 메소드

- `void a();` 와같은 방식으로 선언하는 메소드를 의미한다.
- 아무 표시를 명시하지 않을 경우 접근제어자로 `abstract`와 `public`이 생략되어 있다.

### 정적(static) 메소드

- 접근 제어자에 `public`이 default로 선언되어있다.
- 일반 Class에서 사용하는것처럼 사용이 가능하다.

### Default 메소드

- 특징

  - 구현체에서 메소드를 구현하는 것이 아닌 모든 구현체한테 기본적으로 메소드를 제공할 수 있는 방법.
  - Default를 사용할 경우 해당 **인터페이스를 구현한 모든 구현체(상속받은 클래스)들을 꺠트리지 않고 새 기능의 추가**가 가능하다.
    - 꺠트리지 않는다란? Interface에 추상 메소드를 추가하게 될 경우 구현체(상속받은 클래스)들이 모두 구현을 해야하는 것을 의미한다.
  - 인터페이스를 상속받는 하위 인터페이스에서 **다시 추상 메소드로**변경이 가능하다.
  - **구현체(상속받은 클래스)가 다시 Ovveride**하는것이 가능하다.
  - 내가 만든 인터페이스에서만 작업이 가능하고, 받아온 라이브러리 등의 인터페이스에는 추가가 불가능하다
    - 당연한거 아닌가...?

- 주의사항
  - 복수 개의 인터페이스를 구현해야 할 구현체(상속받은 클래스)가 존재할 때 복수개의 인터페이스에서 Default메소드가 동일한 명칭으로 존재할 경우 (Diamond Problem이 발생할 때) Compiler에서는 어느 메소드를 사용해야할지 판단이 불가능 하기 떄문에 구현체(상속받은 클래스) 에서 직접 Override를 진행해야 한다.
  - 기본 메소드가 **기존의 구현체(상속받은 클래스)가 모르게 추가된 기능**이다.
    - **컴파일 에러가 발생하지 않기 때문**에 default문구를 확인하기 전에는 기능 구현을 파악하기 힘들어 원하는 대로 기능 동작이 발생하지 않을 수 있다.
    - **반드시 문서화**하는 것을 권장한다
      - `@implSpec`이라는 JavaDoc태그를 사용하는걸 권장한다.
  - **Object**클래스에서 제공하는 기능을 **Default Method**로 생성하는 것은 불가능 하다.
    - **Object**클래스에서 Override하는 클래스는 **구현체(상속받은 클래스)에서 직접 Override**해야 한다.
    - 추상 메소드로의 선언은 문제없으나, 애초애 Object가 상속이니까 굳이 추상 메소드 정의도 필요없다 생각한다.

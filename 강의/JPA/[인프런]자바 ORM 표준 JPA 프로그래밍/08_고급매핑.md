# 고급매핑

## Index

- [고급매핑](#고급매핑)
  - [Index](#index)
  - [상속관계 매핑](#상속관계-매핑)
    - [논리 모델을 물리모델 (객체를 DB테이블화 하는방법)](#논리-모델을-물리모델-객체를-db테이블화-하는방법)
      - [조인 전략](#조인-전략)
      - [단일 테이블전략 (Single Table)](#단일-테이블전략-single-table)
      - [구현 클래스마다 테이블 전략](#구현-클래스마다-테이블-전략)
      - [DTYPE](#dtype)
  - [Mapped Superclass의 매핑정보 상속](#mapped-superclass의-매핑정보-상속)

---

## 상속관계 매핑

- 객체는 상속관계가 존재하나 RDB의 경우에는 상속관계가 없으며, 비슷하게 지원하는 DB가 존재는 한다.
- 관계형DB에는 슈퍼타입, 서브타입이라는 관계의 모델링 기법이 객체상속과 유사하다.
- 상속관계 매핑은 객체의 상속과 구조와 DB의 슈퍼타입 서브타입 관계를 매핑한다.

### 논리 모델을 물리모델 (객체를 DB테이블화 하는방법)

#### 조인 전략

- PK, FK를 구축하고 조인으로 데이터를 가져오는 방식
- 메인이 되는 테이블에 `@Inheritance(stratgy=InheritanceType.JOINED)`의 선언이 필요하다.

- 장점
  - 데이터가 정규화가 되어있다
  - 제약조건을 부모클래스에 걸어서 다루기가 쉬움.
  - 외래키 참조 무결성 제약조건을 다루기 십다
  - 저장공간을 효율적으로 활용이 가능하다.
- 단점
  - 조회시 조인을 많이 사용하기에 성능의 저하가 발생가능
  - 조회쿼리가 복잡하다.
  - 데이터 저장시 INSERT SQL가 2번 호출된다.

#### 단일 테이블전략 (Single Table)

- 한개의 테이블에 모든 컬럼을 전부 넣는 방식
- JPA의 기본 테이블 전략으로 설정되어있다.
- 해당 전략은 [DTYPE](#dtype)이 필수적으로 필요하다.
  - 어떤 객체로 선언되었는지 정보가 필요하기 떄문
- 메인이 되는 테이블에 `@Inheritance(stratgy=InheritanceType.SINGLE_TABLE)`로 선언이 필요하다

  - `@DiscriminatorColumn`가 선언이 되어있지 않아도 자체적으로 생성이 된다.

- 장점
  - 조인이 필요가 없어 조회 성능이 빠르다.
  - 조회 쿼리가 조인전략에 비해 단순하다.
- 단점
  - 자식엔티티가 매핑한 컬럼에 대해서 모두 null허용을 해야한다
  - 단일테이블에 모든 데이터를 저장하므로 테이블이 커질수 있고 상황에 따라서는 조회성능이 조인전략에 비해 떨어진다.

#### 구현 클래스마다 테이블 전략

- 각각의 항목마다 따로따로 테이블을 구축하는 전략
- 부모 테이블을 추상클래스로 선언을 하며, `@Inheritance(stratgy=InheritanceType.TABLE_PER_CLASS)`로 설정한다.
- `@DiscriminatorColumn`, `@DiscriminmatorValue`가 필요없어 작동되지 않음.
- 그냥쓰지말자는 추천...

- 장점
  - 서브타입을 명확히 구분해서 처리할 떄 효과적이다
  - Not Null제약조건의 사용이 가능하다
- 단점
  - 여러 자식테이블을 함께 조회할 때 성능이 매우느리다
    - 구현클래스 방법은 조회시 UNION 을 하기 떄문이다.
  - 자식테이블을 통합해서 쿼리하는게 매우 힘들다
  - 시스템이 새로운 타입이 추가될때 많은 부분의 수정이 필요하기에 불편하다

#### DTYPE

- 부모에 선언하는 Annotation은 `@DiscriminatorColumn`
  - Default로 생성되는 Column은 DTYPE이다
  - 선언이 안되어 있으면 따로 컬럼이 생성되지는 않으며, 문제는 없다.
    - 구분하기만 힘들뿐
  - 선언시 하위 타입이 어떠한 타입인지를 부모의 테이블에 생성된다.
  - 컬럼의 변경울 원하면 `name` attribute를 사용하면 된다.
- 자식의 경우에는 Annotation은 `@DiscriminmatorValue`
  - 부모와 마찬가지로 꼭 선언하지 않아도되며 선언하지 않으면 ClassName이 들어간다.
  - 자식에 선언하는 어노테이션으로 선언을 할경우 해당 Value로 삽입된다.

---

## Mapped Superclass의 매핑정보 상속

# JPA 시작하기

## Index

- [JPA 시작하기](#jpa-시작하기)
  - [Index](#index)
  - [영속성 컨텍스트 1](#영속성-컨텍스트-1)
    - [JPA에서 가장 중요한 2가지](#jpa에서-가장-중요한-2가지)
    - [엔티티 매니저 팩토리와 엔티티 매니저에 대한 이해](#엔티티-매니저-팩토리와-엔티티-매니저에-대한-이해)
    - [영속성 컨텍스트란 뭔가?](#영속성-컨텍스트란-뭔가)
    - [환경별 영속성 컨텍스트의 환경](#환경별-영속성-컨텍스트의-환경)
      - [J2SE환경](#j2se환경)
      - [J2EE, Spring Framework같은 컨테이너 환경](#j2ee-spring-framework같은-컨테이너-환경)
    - [엔티티의 생명 주기](#엔티티의-생명-주기)
  - [영속성 컨텍스트 2](#영속성-컨텍스트-2)
    - [1차 캐시의 이점](#1차-캐시의-이점)
      - [1차 캐시에 존재하지 않는 경우의 조회과정](#1차-캐시에-존재하지-않는-경우의-조회과정)
      - [1차 캐시 EntityManager에 대해서](#1차-캐시-entitymanager에-대해서)
      - [2차 캐시?](#2차-캐시)
    - [영속된 엔티티의 동일성 보장](#영속된-엔티티의-동일성-보장)
      - [등록시 트랜잭션을 지원하는 쓰기 지연](#등록시-트랜잭션을-지원하는-쓰기-지연)
      - [등록되는 순서](#등록되는-순서)
    - [수정이 이뤄질때 과정](#수정이-이뤄질때-과정)
    - [삭제](#삭제)
  - [플러시](#플러시)
    - [플러시란?](#플러시란)
    - [플러시 발생](#플러시-발생)
    - [영속성 컨텍스트를 직접 플러시하는 방법](#영속성-컨텍스트를-직접-플러시하는-방법)
      - [플러시 자동 호출 관련 설명](#플러시-자동-호출-관련-설명)
    - [플러시 모드 옵션 변경방법](#플러시-모드-옵션-변경방법)
      - [FlushModeType Enum](#flushmodetype-enum)
      - [FlushModeType별 기능](#flushmodetype별-기능)
    - [flush 동작과 관련한 예제](#flush-동작과-관련한-예제)
  - [준영속 상태](#준영속-상태)
    - [영속상태가 되는 경우](#영속상태가-되는-경우)
    - [준영속상태란](#준영속상태란)
    - [준영속상태로 만드는법](#준영속상태로-만드는법)
      - [특정 엔티티만 준영속상태로 원할시](#특정-엔티티만-준영속상태로-원할시)
      - [영속성 컨텍스트의 완전 초기화를 원할 시.](#영속성-컨텍스트의-완전-초기화를-원할-시)
      - [영속성 컨텍스트를 종료하고자 하는 경우](#영속성-컨텍스트를-종료하고자-하는-경우)
    - [준영속상태가 되었을때 발생되는 일](#준영속상태가-되었을때-발생되는-일)

---

## 영속성 컨텍스트 1

### JPA에서 가장 중요한 2가지

1. 객체(Object)와 관계형DB(RDBMS)를 설계하는 매핑
2. 실제 JPA가 내부에서 어떻게 동작하는지 관계된 영속성 컨텍스트

### 엔티티 매니저 팩토리와 엔티티 매니저에 대한 이해

Request가 오는 경우 EntityManagerFactory는 EntityManager를 생성해서 DB Connection을 맺어서 사용하게 된다.

### 영속성 컨텍스트란 뭔가?

1. JPA를 이해하는데 가장 중요한 용어이다.
2. "엔티티를 영구 저장하는 환경"이라는 뜻
3. `EntityMAnager.persis(entity)`는 즉 DB에 값을 저장하는게 아니라 영속성 컨텍스트에 값을 저장한다는 의미이다.

### 환경별 영속성 컨텍스트의 환경

#### J2SE환경

EntityManager와 PersistenceContext(영속성 컨텍스트)가 **1:1** 환경으로 생성된다.

#### J2EE, Spring Framework같은 컨테이너 환경

EntityManager와 PersistenceContext가 **N : 1** 환경으로 생성된다.

### 엔티티의 생명 주기

- 비영속 (new / transient)
  - 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
  - Entity객체를 새로 만든 경우
- 영속 (managed)
  - 영속성 컨텍스트에 관리되는 상태
  - 새로 생성한 Entity객체를 Persist를 진행한 경우
- 준영속 (detached)
  - 영속성 컨텍스트에 저장되었다가 분리된 상태
  - 영속화된 객체를 `detached`메소드를 활용할 경우 영속된 객체를 해제하는것을 의미
- 삭제 (removed)
  - 삭제된 상태
  - 실제 영구 저장된 객체를 삭제하는 상태

---

## 영속성 컨텍스트 2

> 영속성 컨텍스트는 내부에 1차캐시라는 것을 들고 있다.

### 1차 캐시의 이점

> 만약 영속성 컨텍스트에 객체가 managed상태인 경우 1차캐시에 존재할 것이며, 조회를 하고자 하는 경우 DB를 우선 조회하는게 아닌 캐시를 먼저 조회하게 된다.

#### 1차 캐시에 존재하지 않는 경우의 조회과정

1. 1차캐시를 일단 먼저 확인한다.
2. DB를 조회하여 데이터를 가져온다.
3. 1차캐시에 조회한 데이터를 저장한다.
4. 데이터의 반환

#### 1차 캐시 EntityManager에 대해서

> 1차 캐시를 저장하는 EntityManager의 경우 Transaction단위로 작업이후 삭제를 진행하기 때문에 어플리케이션 전체에서 캐시를 공유하진않는다.

#### 2차 캐시?

> 2차캐시의 공유영역은 Application전체이다.

### 영속된 엔티티의 동일성 보장

> 트랙잭션내에서 영속된 엔티티의 경우 몇번을 조회해도 `동일한 객체`를 반환한다

#### 등록시 트랜잭션을 지원하는 쓰기 지연

```
// 1차캐시저장과, SQL문을 제작만하고 쓰기지연 SQL저장소에 저장만 함.
em.persist(memberA);
em.persist(memberB);

//이때 INSERT SQL을 전달
transaction.commit();
```

#### 등록되는 순서

1. SQL저장소 쿼리저장
2. Flush(플러쉬)
   1. 해당과정에서 쿼리를 DB로 전달
3. commit

### 수정이 이뤄질때 과정

> 수정시에는 변경감지라고하며 더티체킹이라는 명칭의 과정이 이뤄진다.

1. flush
2. 조회해서 데이터가 영속성 컨텍스트에 들어온 경우 생성된 스냅샷과 현재 보유중인 entity객체의 데이터를 비교함.
3. Update SQL 생성
4. flush
5. commit

### 삭제

삭제는 직접 entity를 remove이후 commit을 해야한다.

---

## 플러시

### 플러시란?

> 영속성 컨텍스트의 변경 내용을 DB에 반영하는것
> 쉽게 말하면, 쓰기지연 SQL저장소에 저장된 쿼리를 반영하는 과정.

> 영속성 컨텍스트의 변경 사항에 대해서 DB에 쿼리를 발송하여 동일하게 맞추는 것.

### 플러시 발생

1. 변경감지 (Dirty Checking)
2. 수정된 Entity쓰기 지연 SQL저장소에 등록
3. 쓰기지연 SQL저장소의 쿼리를 DB에 전송 (등록, 수정, 삭제쿼리등)

### 영속성 컨텍스트를 직접 플러시하는 방법

> 직접 하는 경우는 사실 손해지만 테스트하는 경우등에서는 필요한 경우가 있다.

1. entityManager.flush() - 직접 호출
2. Transaction 커밋 - 플러시 자동 호출
3. JPQL 쿼리 실행 - 플러시 자동 호출

#### 플러시 자동 호출 관련 설명

1. Transaction 커밋
   1. entityTransaction의 Commit을 실행 할 때 flush 를 실행하도록 구현됨.
2. JPQL 쿼리 실행시
   1. JPQL의 경우 SQL문으로 번역되서 바로 실행이 된다. 즉 현재 영속성 컨텍스트에 담긴 정보와 일치하지 않는 경우 문제가 발생 할 수 있기 때문에 JPQL의 경우에는 무조건 flush를 실행시키도록 구현되어있다.

### 플러시 모드 옵션 변경방법

> 해당 명령어메소드를 통해 설정 가능

> FlushModeType.AUTO가 Default값이며, AUTO, COMMIT 두개가 존재한다.

```
entityManager.setFlushMode(FlushModeType의 Enum값);
```

#### FlushModeType Enum

```
package javax.persistence;

public enum FlushModeType {
  COMMIT,
  AUTO;

  private FlushModeType() {
  }
}
```

#### FlushModeType별 기능

1. AUTO
   1. 커밋이나 쿼리를 실행할 때 Flush를 한다.
2. COMMIT
   1. 커밋을 할 때만 Flush를 한다

### flush 동작과 관련한 예제

> SQL 쓰기지연 저장소에 5개의 쿼리가 있는경우

1. 5번의 통신 + 1번의 Commit → 6회 통신
2. 1번에 5번의 쿼리 발송 + 1번의 Commit → 2회 통신

결과는 2개 모두 가능하다.해당 부분은 추후 성능최적화에서 참조

---

## 준영속 상태

### 영속상태가 되는 경우

> 아래 작업을 통해 1차캐시에 올라간 상태를 영속상태라 칭함.

1. persist
2. find

### 준영속상태란

> 영속 상태의 Entity가 영속성 컨텍스트에서 분리(detached)가 된 상태를 의미한다.
>
> 또한 영속성 컨텍스트가 제공하는 기능을 사용하지 못하게 된다.

### 준영속상태로 만드는법

#### 특정 엔티티만 준영속상태로 원할시

> 영속상태가 된 Entity객체를 detach메소드를 활용해서 해제가 가능하다.

```
EntityManager.detach(희망하는 Entity객체);
em.detach(member);
```

#### 영속성 컨텍스트의 완전 초기화를 원할 시.

> 모든 Entity를 통으로 초기화 시킴

```
EntityManager.clear();
em.clear();
```

#### 영속성 컨텍스트를 종료하고자 하는 경우

```
EntityManager.close();
em.close();
```

### 준영속상태가 되었을때 발생되는 일

> 객체에 대한 정보를 수정한 경우 Commit을 진행할 때 추가적인 작업이 이뤄지지 않는다.

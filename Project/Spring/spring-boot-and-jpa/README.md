# README

인프런 - SpringBoot JPA활용 1 강의를 듣고 정리한 내용입니다.

## Entity 설계 주의사항

- Setter를 사용하지 않는다.
    - Setter가 모두 열려있게 되면, 변경 포인트가 너무 많아지게 되어 유지보수가 힘들다.
- 모든 연관관계는 지연로딩(LAZY)으로 설정한다.
    - 즉시 로딩(EAGER)의 경우에는 예측이 힘들고, SQL의 실행 추적이 힘들다
    - 특히 JPQL을 실행 할 때 N+1 문제가 자주 발생한다
    - 연관된 엔티티를 함께 DB에서 조회할 필요가 있는경우, fetch join또는 엔티티 그래프 기능을 활용한다.
- 컬렉션은 필드에서 초기화 한다.
    - null 문제에서 안전하다.
    - 하이버네이트는 엔티티를 영속화 시킬 때 컬렉션을 감싸서 하이버네이트가 제공하는 내장 컬렉션으로 변경한다. 이때 임의의 메서드에서 컬렉션을 잘못 생성하면, 하이버네이트 내부매커니즘에 문제가 발생할 수 있기
      때문에, 필드레벨에서 생성하는것이 가장 안전하고, 코드가 간결함
- 기본 생성자는 PROTECTED로 설정한다.
    - 객체(Entity)를 생성을 못하게 막기 위함
- cascade
    - ALL
        - 모든 변경에 대해 연관관계를 같이 변경한다.

## 변경 감지(DirtyChecking) 와 병합(Merge)

### 준영속 엔티티?

- 영속성 컨텍스트가 더이상 관리하지 않는 엔티티를 말한다.
    - ItemController에서, updateEntity로 직접 생성한 엔티티를 칭할 수 있다.
    - DB에서 조회하여 엔티티를 생성하였으나, 실제 영속성 컨텍스트로 관리는 되고 있지 않기 때문

#### 준영속 엔티티를 수정하는 2가지 방법

- 변경 감지 기능 사용
    - 영속성 컨텍스트에 엔티티를 다시 조회한 후(Repository로 조회한 이후)에, 해당 엔티티의 값을 변경한다.
- 병합(merge) 사용
    - 병합은 준영속 상태의 엔티티를 영속 상태로 변경할 때 사용한다.
    - 병합시, 파라미터로 넘어온 엔티티의 식별자 값으로 영속성 컨텍스트에서 엔티티를 조회하고, 조회된 엔티티에 값을 채워 넣는다(혹은 변경).

### 병합 동작방식

1. `merge()`를 실행한다.
2. 파라미터로 넘어온 준영속 엔티티의 식별자 값으로 영속성 컨텍스트에서 엔티티를 조회한다.
3. 만약 캐시에 엔티티가 없으면 데이터베이스에서 엔티티를 조회하고, 그리고 1차 캐시에 저장한다.
4. 조회한 영속 엔티티(mergeMember)에 member 엔티티의 값을 채워 넣는다.
5. 영속 상태인 mergeMember를 반환한다.

#### 병합시 주의사항

> [!WARNING]  
> `merge(Entity)`로 영속성 컨텍스트에 넣은 Entity자체는 등록이 되지 않고, `merge(Entity)`를 통해 반환받은 Entity가 관리된다.
> 그래서 추가적인 작업을 진행해야 하는 경우에는 `merge(Entity)`를 통해 반환받은 Entity를 사용해야 한다.

> [!WARNING]
> DirtyChecking을 사용하는 경우에는 원하는 속성만 선택하여 변경이 가능하지만, 병합을 사용하는 경우에는 모든 속성이 변경된다.
> 또한 병합시 실제 값이 없는 경우에는 Null로 바뀌어 버리는 문제가 발생 할 수도 있다 (병합은 모든 필드를 교체하기 때문)

### 권장 방법

- 변경 감지 기능을 사용한다.

## Controller의 주의사항

- Entity반환하지 마라

## API 개발 관련 내용

### 패키지

RestAPI와 Controller의 경우 분할이 나음. 이유는 공통적으로 처리해야 하는 요소가, MVC를 활용한 SSR을 할 경우에는 에러페이지가 나가야하는 반면,
RestAPI의 경우에는 에러메시지를 내려줘야 하기 때문에 분리하는 것이 좋다.

### 조회 기능의 API 성능 최적화

- 조회만 있는 이유는 등록, 수정, 삭제의 경우 금방 처리되는데 조회는 연관되어 묶여있고, LAZY로딩도있고 해서 성능을 챙기는 방법을 따로 알아야한다.

#### 지연 로딩과 조회 성능 최적화

주문 + 배송정보 + 화면을 조회하는 API
지연로딩 때문에 발생되는 성능 문제를 단계적으로 해결해나가기

##### 엔티티를 직접 조회하는 V1방식

내부에 매핑이 되어있는 항목들이 모두 Lazy로딩으로, JsonIgnore를 하지 않으면, 추후 객체를 내보낼때 Jackson에서 StackOverFlow가 발생한다.
그래서 JsonIgnore를 사용하면, 해당 객체는 내보내지 않는다.

또한 Lazy로 N+1문제가 발생하는데 이걸 해결해기 위해 EAGER로딩으로 변경을 하면 실제 문제해결이 된것은 아니다.
이를 해결하기 위해서는, fetch join을 사용하면 된다.

##### 엔티티를 DTO로 변환하는 V2방식

조회한 Entity를 Response로 내보낼 DTO에 매핑하여 변환해 내보내는 방식이다.

이때, 별다른 조치를 하지 않는 경우 Lazy로딩설정이 된 항목의 경우 N+1이 v1과 동일하게 발생한다.

##### 엔티티를 DTO로 변환하고, fetch join으로 성능 최적화한 V3방식

fetch join을 사용하여, N+1문제를 해결하고, DTO로 변환하여 내보내는 방식이다.

##### JPA에서 DTO로 바로 조회하는 V4방식

JPA에서 DTO로 바로 조회하는 방식으로, 직접 쿼리를 작성하여 조회하는 방식은 V3와 같으나, 필드까지 지정할 수 있게 되며, Entity와 Dto를 쿼리에서 매핑해야한다

쿼리 방식의 선택 권장순서는 다음과 같다.

1. 엔티티를 우선 DTO로 변환하는 방법을 선택한다.
2. 필요하면 fetch join으로 성능을 최적화 한다.
3. 그래도 안되면 DTO로 직접 조회하는 방법을 사용한다.
4. 최후의 방법은 JPA가 제공하는 네이티브 SQL이나 스프링 JDBC Template을 사용해서 SQL을 직접 사용한다.

### 컬렉션 조회 최적화

OneToMany의 경우에는, fetch join을 사용하면, 데이터가 중복되어 나오는 문제가 발생한다.
관련된 매핑을 최적화하는 방식에 대한 기록.

#### Batch의 설정

Batch의 역할은, 조회해야할 쿼리에 대해 IN절을 사용하여 한번에 조회하는 방식이다.

- 보통 `spring.jpa.hibernate.properties.default_batch_fetch_size`로 기본값의 설정이 가능하며, 100~1000정도로 설정하는 것이 좋다.
- 개별적인 적용을 하고 싶을 때는 Annotation으로 Entity에 선언이 가능하며, `@BatchSize(size= {value})`형식으로 적용이 가능하다
    - `@BatchSize`는 컬렉션 필드에는 필드위에 어노테이션을 선언하면 된다.
    - 컬렉션 필드가 아닌 경우에는 클래스위에 어노테이션을 선언하면 된다.

#### Batch 설정 주의사항

최대 1000개라고 생각하자.

### fetch조인의 단점

- 데이터가 중복되어 조회된다.
    - distinct를 통해서 해결해 중복을 제거해야하나, Hibernate 6.0부터는 distinct를 사용하지 않아도 중복을 제거해준다.
    - Hibernate 6.0이전에는 distinct를 사용해야한다.
- 페이징이 불가능하다.
    - 일대다에서 일(1)을 기준으로 페이징을 하면, 데이터가 부정합하게 조회될 수 있다.
    - 일대다에서 다(N)을 기준으로 페이징을 하면, 데이터가 중복해서 조회될 수 있다.
- 컬렉션에서 fetch Join을 사용해야 할 경우에는 컬렉션을 두개 이상을 사용할 경우 데이터가 부정합하게 조회될 수 있다.
    - 한개만 쓰도록..

### 컬렉션 조회 최적화 - 페이징과 한계 돌파

- ToOne 관계는 fetch join으로 최적화
- ToMany 관계는 hibernate.default_batch_fetch_size, @BatchSize로 최적화
- ToOne관계만 조회한뒤, 페이징은 정상적으로 기능작동이 가능함. 이후 Batch를 동해서 N+1문제를 해결한다.

## OSIV
- Open Session In View의 약자이다
- JPA에서의 EntityManager가 하이버네이트의 Session과 동일하다.

### OSIV 커넥션 설정에 대해
- DB의 커넥션의 시작 트랜잭션이 묶였을때로 볼 수 있으나 종료는 OSIV설정에 따라 달라진다.
  - OSIV ON의 경우에는, View가 렌더링 될때까지 트랜잭션을 유지한다.
  - API인 경우에는, API가 끝날때까지 트랜잭션을 유지한다.
  - OSIV OFF의 경우에는, 서비스 로직이 끝나면 트랜잭션을 종료한다.(보통 트랜잭션 원자성을 Service까지만 쓰니까 서비스라 칭함)

### OSIV ON
- 설정은 `spring.jpa.open-in-view=true`로 설정한다.

#### ON일때의 장단점
- 장점
  - 트랜잭션을 종료할때까지 View Template에서 지연로딩이 가능하다.
- 단점
  - 커넥션을 차지하는 시간이 너무 길다
  - 실시간 트래픽이 중요한 어플리케이션에서 요청이 많을 떄 커넥션을 차지하는 시간이 길어지면, 커넥션 풀이 고갈되어 서버가 죽을 수 있다.

### OSIV OFF
- 설정은 `spring.jpa.open-in-view=false`로 설정한다.

#### OFF일때의 장단점
- 장점
  - 커넥션을 차지하는 시간이 짧다
- 단점
  - Transaction원자성이 종료되는 영역에서, 지연로딩 객체의 호출(사용)이 불가능하다.

## 권장하는 방법
- 트래픽이 많은 경우에는 Off, ADMIN같은 요청이 많으 없는 프로젝트에서는 ON을 해서 편의성을 높이는게 편하다.


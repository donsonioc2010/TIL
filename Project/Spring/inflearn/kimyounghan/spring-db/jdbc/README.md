# README

## Transaction
한국어로는 거래라는 의미, DB에서의 트랜잭션은 하나의 거래를 안전하게 처리하도록 보장하는 것을 의미.

여러개의 쿼리를 동시에 실행해야 할때, 모든작업이 성공해야 반영하게 하는 Commit과 작업중 하나라도 실패시 거래 이전으로 돌리는 Rollback이 핵심

### 트랜잭션의 ACID
- Atomicity (원자성)
  - 트랜잭션의 모든 연산이 정상적으로 수행되어야만 성공
  - 하나라도 실패하면 전체가 실패
- Consistency (일관성)
  - 트랜잭션이 성공적으로 완료되면 일관성있는 상태로 유지
- Isolation (고립성, 격리성)
  - 트랜잭션은 다른 트랜잭션과 격리되어 실행되어야 함
  - 다른 트랜잭션의 연산이 트랜잭션에 영향을 미치지 않아야 함
- Durability (지속성)
  - 트랜잭션이 성공적으로 완료되면 영구적으로 반영되어야 함
  - 시스템에 문제가 발생해도 트랜잭션의 결과는 보존되어야 함

> 트랜잭션은 이러한 ACID를 보장해야 한다. 하지만 큰 문제가 있는데, 그것은 바로 격리성이며, 태른잭션간에 격리성을 완벽히 보장하려면 트랜잭션을 거의 순서대로 실행해야 하기 때문에 성능이 떨어진다. 
> 이런 문제로 인하여 ANSI표준은 트랜잭션 격리 수준을 4단계로 나누어 정리하였다.

### 트랜잭션 격리 수준 - Isolation Level
> 레벨이 높아질 수록 격리성이 높아지지만 성능이 떨어진다.
> 자주 사용되는 레벨은 Read Committed와 Repeatable Read이다.

- Read Uncommitted (레벨 0)
  - 다른 트랜잭션이 커밋하지 않은 데이터를 읽을 수 있음
  - Dirty Read, Non-Repeatable Read, Phantom Read 발생 가능
- Read Committed (레벨 1)
  - 다른 트랜잭션이 커밋한 데이터만 읽을 수 있음
  - Dirty Read는 발생하지 않음
  - Non-Repeatable Read, Phantom Read 발생 가능
- Repeatable Read (레벨 2)
  - 트랜잭션 내에서 같은 쿼리를 실행하면 같은 결과가 나와야 함
  - Dirty Read, Non-Repeatable Read는 발생하지 않음
  - Phantom Read 발생 가능
- Serializable (레벨 3)
  - 트랜잭션 간에 격리성을 완벽하게 보장
  - Dirty Read, Non-Repeatable Read, Phantom Read 모두 발생하지 않음

### 트랜잭션의 시작위치와 비즈니스 로직
- 트랜잭션의 시작은 비즈니스 로직이 존재하는 서비스 계층에서 시작해야 한다. 비즈니스 로직이 잘못되면 해당 비즈니스 로직으로 인해 문제가 되는 부분을 함께 롤백해야 하기 떄문
- 트랜잭션을 시작하기 위해서는 커넥션이 필요하며, 결국 서비스계층에서 커넥션을 생성하고 트랜잭션 커밋이후 커넥션을 종료해야함.
- 어플리케이션에서 **DB 트랜잭션을 사용하려면 트랜잭션을 사용하는 동안 같은 커넥션을 유지**해야한다. 그래야 **같은 DB세션을 사용** 할 수 있기 떄문.